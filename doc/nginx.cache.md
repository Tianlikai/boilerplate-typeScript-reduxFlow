# nginx 服务器缓存策略

## 强缓存和协商缓存

### 强缓存

我们知道，强缓存主要是通过 http 请求头中的`Cache-Control`和`Expire`两个字段控制。`Expire`是 `HTTP1.0` 标准下的字段。
一般，我们会设置`Cache-Control`的值为`max-age=xxx`,表示在 xxx 秒内再次访问该资源，均使用本地缓存，不再向服务器发起请求。

显而易见，如果在 xxx 秒内，服务器上面的资源如果发生了改变，客服端在没有强制刷新的情况下，看到的内容还是旧的。

### 协商缓存

协商缓存最大的问题是每次都要向服务器验证一下缓存的有效性，似乎看起来很省事，不管那么多，你都需要问一下是否有效。但是为了追求效率，每次都去访问是比较低效的选择。

### 实践

缓存的意义在于减少请求，更多的使用本地的资源，给用户更好的体验同时，也减轻服务器的压力。所以最佳实践，就应该是尽可能命中缓存，同时，能在更新版本的时候让客户的缓存失效。

在更新版本的时候，如何让用户更新静态资源文件呢？当然是在更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在缓存的问题了。

`webpack`可以为我们提供一个比较合理的方案：

- `HTML`: 使用协商缓存
- 其他文件: 使用强缓存

### hash 类型

webpack 给我们提供了三种哈希计算方式，分别是 hash，chunkhash，contenthash。那么三种哈希有什么区别呢?

- hash: 更整个文件构建相关，构建生产的 hash 都是一样的，只要项目文件里有更改，整个项目的 hash 都会改变。
- chunkhash：根据不同的入口进行依赖文件解析，构建对于的 chunk，生成对应的 hash 值。
- contenthash：由文件内容产生的 hash 值，文件内容不同产生 hash 不同。

显然，我们是不会使用第一种的。改了一个文件，打包之后，其他文件的 hash 都变了，缓存自然都失效了。这不是我们想要的。

那 chunkhash 和 contenthash 的主要应用场景是什么呢？在实际在项目中，我们一般会把项目中的 css 都抽离出对应的 css 文件来加以引用。如果我们使用 chunkhash，当我们改了 css 代码之后，会发现 css 文件 hash 值改变的同时，js 文件的 hash 值也会改变。这时候，contenthash 就派上用场了。

### ETag 和 Last-Modified 谁优先

协商缓存，有 ETag 和 Last-Modified 两个字段。那当这两个字段同时存在的时候，会优先以哪个为准呢？
